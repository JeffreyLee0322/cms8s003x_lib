C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CMS8S003X_UART
OBJECT MODULE PLACED IN .\Objects\cms8s003x_uart.obj
COMPILER INVOKED BY: D:\Install software\keil5\C51\BIN\C51.EXE ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_
                    -uart.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\CMS8S003x_StdPeriph_Driver\inc) DEBUG PRINT(.\Listings\cms8s
                    -003x_uart.lst) TABS(2) OBJECT(.\Objects\cms8s003x_uart.obj)

line level    source

   1          /**
   2            ********************************************************************************
   3            * @file    cms8s003x_uart.c
   4            * @author  LI WEI
   5            * @version V1.0.3
   6            * @date    04/24/2018
   7            * @brief   This file provides all the UART firmware functions.
   8            ******************************************************************************
   9            * @copy
  10            *
  11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13            * TIME. AS A RESULT, CMSemicon SHALL NOT BE HELD LIABLE FOR ANY
  14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17            *
  18            * <h2><center>&copy; COPYRIGHT 2018 CMSemicon</center></h2>
  19            */
  20          
  21          /* Includes ------------------------------------------------------------------*/
  22          #include <stdio.h>
  23          #include "cms8s003x_uart.h"
  24          
  25          /** @addtogroup CMS8S003x_StdPeriph_Driver
  26            * @{
  27            */
  28          
  29          /* Private typedef -----------------------------------------------------------*/
  30          /* Private define ------------------------------------------------------------*/
  31          //#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
  32          
  33          /* Private macro -------------------------------------------------------------*/
  34          /* Private variables ---------------------------------------------------------*/
  35          /* Private function prototypes -----------------------------------------------*/
  36          /* Private functions ---------------------------------------------------------*/
  37          /* Public functions ----------------------------------------------------------*/
  38          
  39          /** @}
  40            * @addtogroup UART_Public_Functions
  41            * @{
  42            */
  43          
  44          /**
  45            * @brief   Deinitializes the USART peripheral.
  46            * @param  UARTx : where x can be 1, 2 or 3 to select the specified USART peripheral.
  47            * @retval None
  48            */
  49          void USART_DeInit(UART_TypeDef UARTx)
  50          {
  51   1      
  52   1      }
*** WARNING C280 IN LINE 49 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_uart.c: 'UARTx': unreferenced lo
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 2   

             -cal variable
  53          
  54          /**
  55            * @brief  Initializes the USART according to the specified parameters.
  56            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
  57            *         correct I/O Port register according the product package and line
  58            *         configuration
  59            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
  60            * @param  BaudRate : The baudrate.
  61            * @param  USART_WordLength : This parameter can be any of the
  62            *         @ref USART_WordLength_TypeDef enumeration.
  63            * @param  USART_StopBits : This parameter can be any of the
  64            *         @ref USART_StopBits_TypeDef enumeration.
  65            * @param  USART_Parity : This parameter can be any of the
  66            *         @ref USART_Parity_TypeDef enumeration.
  67            * @param  USART_Mode : This parameter can be any of the @ref USART_Mode_TypeDef values
  68            * @retval None
  69            */
  70          void UART_Init(UART_TypeDef UARTx, UART_Init_TypeDef* UART_InitDef)
  71          {
  72   1        uint32_t BaudRate_Mantissa = 0;
  73   1      
  74   1        /* Check the parameters */
  75   1      
  76   1        if(UARTx == UART0)
  77   1        {
  78   2          SCON0 &= 0;
  79   2          SCON0 |= ((uint8_t)(UART_InitDef->Mode) | ((uint8_t)(UART_InitDef->MutiDevices) << 5) | ((uint8_t)(UART_
             -InitDef->IsReceive) << 4) | ((uint8_t)(UART_InitDef->SendData9Bit) << 3) | ((uint8_t)(UART_InitDef->ReceiveData9Bit) << 
             -2));
  80   2          
  81   2          PCON &= ~0x80;
  82   2          PCON |= ((uint8_t)(UART_InitDef->UartBaudrateDouble) << 7);
  83   2          
  84   2          if((Mode_8Bit_Unsettled_Freq == UART_InitDef->Mode) || (Mode_9Bit_Unsettled_Freq == UART_InitDef->Mode))
  85   2          {
  86   3            if(Timer1_Select == UART_InitDef->UartClkSource)
  87   3            {
  88   4              /* Set Timer1 as uart0`s clock source */
  89   4              FUNCCR &= 0xfe; 
  90   4              //setup timer1
  91   4              /* Timer1 TMOD Clear and Set */
  92   4              TMOD &= 0x0f;
  93   4              TMOD |= 0x20; //GATE1 disable, Timer select, Mode2: 8bit auto reload
  94   4              //CKCON |= 0x10; //Timer1 clock source: sys/4 (systerm clock is 8MHz/16MHz, if not CLKDIV)
  95   4              /*if systerm clock is 16MHz, 16/4=4MHz --> T=0.25us
  96   4              if baudrate is 9600bps->T=1/9600s=104.166us
  97   4              if baudrate is 57600bps->T=1/57600s=17.361us
  98   4              if baudrate is 115200bps->T=1/115200s=8.680us
  99   4              */
 100   4              //TL1 = 256 - (uint16_t)(1000000.0/(UART_InitDef->UartBaurdrate) / 0.25);
 101   4              //TH1 = 256 - (uint16_t)(1000000.0/(UART_InitDef->UartBaurdrate) / 0.25);
 102   4              
 103   4              CKCON &= ~0x10; //Timer1 clock source: sys/12 (systerm clock is 8MHz/16MHz, if not CLKDIV)
 104   4              TL1 = 256 - (uint8_t)(1000000.0 / (UART_InitDef->UartBaurdrate) / 0.75);
 105   4              TH1 = 256 - (uint8_t)(1000000.0 / (UART_InitDef->UartBaurdrate) / 0.75);
 106   4              IE |= 0x88; //Enable Timer1 interrupt
 107   4              TCON |= 0x40; //Timer1 start
 108   4            }
 109   3            else if(Timer4_Select == UART_InitDef->UartClkSource)
 110   3            {
 111   4              /* Set Timer4 as uart0`s clock source */
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 3   

 112   4              FUNCCR |= 0x01;
 113   4              //setup timer4
 114   4              /* Timer4 T34MOD Clear and Set */
 115   4              T34MOD &= 0x0f;
 116   4              T34MOD |= 0x60; //Timer4 clock select:sys/4, Mode2: 8bit auto reload
 117   4              /*if systerm clock is 16MHz, 16/4=4MHz --> T=0.25us
 118   4              if baudrate is 9600bps->T=1/9600s=104.166us
 119   4              if baudrate is 57600bps->T=1/57600s=17.361us
 120   4              if baudrate is 115200bps->T=1/115200s=8.680us
 121   4              */
 122   4              TL4 = 256 - (uint8_t)(1000000.0/(UART_InitDef->UartBaurdrate) * 0.25);
 123   4              TH4 = 256 - (uint8_t)(1000000.0/(UART_InitDef->UartBaurdrate) * 0.25);
 124   4              T34MOD |= 0x80; //Timer4 start
 125   4            }
 126   3          }
 127   2        }
 128   1        else if(UARTx == UART1)
 129   1        {
 130   2          SCON1 &= 0;
 131   2          SCON1 |= ((uint8_t)(UART_InitDef->Mode) | ((uint8_t)(UART_InitDef->MutiDevices) << 5) | ((uint8_t)(UART_
             -InitDef->IsReceive) << 4) | ((uint8_t)(UART_InitDef->SendData9Bit) << 3) | ((uint8_t)(UART_InitDef->ReceiveData9Bit) << 
             -2));
 132   2          
 133   2          PCON &= ~0x40;
 134   2          PCON |= ((uint8_t)(UART_InitDef->UartBaudrateDouble) << 6);
 135   2          
 136   2          if((Mode_8Bit_Unsettled_Freq == UART_InitDef->Mode) || (Mode_9Bit_Unsettled_Freq == UART_InitDef->Mode))
 137   2          {
 138   3            if(Timer1_Select == UART_InitDef->UartClkSource)
 139   3            {
 140   4              FUNCCR &= 0xfd; 
 141   4              //setup timer1
 142   4              
 143   4            }
 144   3            else if(Timer4_Select == UART_InitDef->UartClkSource)
 145   3            {
 146   4              FUNCCR |= 0x02;
 147   4              //setup timer4
 148   4            }
 149   3          }
 150   2        }
 151   1      
 152   1      }
 153          
 154          /**
 155            * @brief  Initializes the USART Clock according to the specified parameters.
 156            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 157            * @param  USART_Clock : This parameter can be any of the @ref USART_Clock_TypeDef
 158            *         enumeration.
 159            * @param  USART_CPOL : This parameter can be any of the @ref USART_CPOL_TypeDef
 160            *         enumeration.
 161            * @param  USART_CPHA : This parameter can be any of the @ref USART_CPHA_TypeDef
 162            *         enumeration.
 163            * @param  USART_LastBit : This parameter can be any of the @ref USART_LastBit_TypeDef
 164            *         enumeration.
 165            * @retval None
 166            */
 167          
 168          void USART_ClockInit()
 169          {
 170   1      
 171   1      }
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 4   

 172          
 173          /**
 174            * @brief  Enable the USART peripheral.
 175            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 176            * @param  NewState : The new state of the USART Communication.
 177            *         This parameter can be any of the @ref FunctionalState enumeration.
 178            * @retval None
 179            */
 180          void USART_Cmd(UART_TypeDef USARTx, FunctionalState NewState)
 181          {
 182   1      
 183   1      }
*** WARNING C280 IN LINE 180 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_uart.c: 'USARTx': unreferenced 
             -local variable
*** WARNING C280 IN LINE 180 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_uart.c: 'NewState': unreference
             -d local variable
 184          
 185          
 186          /**
 187            * @brief  Enables or disables the specified USART interrupts.
 188            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 189            * @param  USART_IT specifies the USART interrupt sources to be enabled or disabled.
 190            *         This parameter can be one of the following values:
 191            *         - USART_IT_TXE:  Tansmit Data Register empty interrupt
 192            *         - USART_IT_TC:   Transmission complete interrupt
 193            *         - USART_IT_RXNE: Receive Data register not empty interrupt
 194            *         - USART_IT_OR: Overrun error interrupt
 195            *         - USART_IT_IDLE: Idle line detection interrupt
 196            *         - USART_IT_ERR:  Error interrupt
 197            * @param  NewState new state of the specified USART interrupts.
 198            *         This parameter can be: ENABLE or DISABLE.
 199            * @retval None
 200            */
 201          
 202          void UART_ITConfig(UART_TypeDef UARTx, UART_Priority_TypeDef UART_Priority, FunctionalState NewState)
 203          {
 204   1        if(UART0 == UARTx)
 205   1        {
 206   2          if (NewState != _DISABLE)
 207   2          {
 208   3            /*Clear and Set uart0 IT priority */
 209   3            IP &= ~0x10;
 210   3            IP |= (UART_Priority << 4);
 211   3            
 212   3            IE |= UART0_INTERRUPT_ENABLE_BIT; /* Enable the UART0 IT */
 213   3          }
 214   2          else
 215   2          {
 216   3            IE &= (uint8_t)(~UART0_INTERRUPT_ENABLE_BIT); /* Disable the UART0 IT */
 217   3          }
 218   2        }
 219   1        else if(UART1 == UARTx)
 220   1        {
 221   2          if (NewState != _DISABLE)
 222   2          {
 223   3            /*Clear and Set uart1 IT priority */
 224   3            IP &= ~0x40;
 225   3            IP |= (UART_Priority << 6);
 226   3            
 227   3            IE |= UART1_INTERRUPT_ENABLE_BIT; /* Enable the UART1 IT */
 228   3          }
 229   2          else
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 5   

 230   2          {
 231   3            IE &= (uint8_t)(~UART1_INTERRUPT_ENABLE_BIT); /* Disable the UART1 IT */
 232   3          }
 233   2        }
 234   1      }
 235          
 236          /**
 237            * @brief  Returns the most recent received data by the USART peripheral.
 238            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 239            * @retval The received data.
 240            */
 241          uint8_t UART_ReceiveData8(UART_TypeDef UARTx)
 242          {
 243   1        /*uint8_t returnData = 0;
 244   1        if(UART0 == UARTx)
 245   1        {
 246   1            returnData = SBUF0;
 247   1        }
 248   1        else if(UART1 == UARTx)
 249   1        {
 250   1            returnData = SBUF1;
 251   1        }
 252   1        
 253   1        return returnData;*/
 254   1        return ((UARTx == UART0)?(uint8_t)SBUF0:(uint8_t)SBUF1);
 255   1      }
 256          
 257          
 258          /**
 259            * @brief  Returns the most recent received data by the USART peripheral.
 260            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 261            * @retval The received data.
 262            */
 263          uint16_t UART_ReceiveData9(UART_TypeDef UARTx)
 264          {
 265   1        /*if(UART0 == UARTx)
 266   1        {
 267   1        
 268   1        }
 269   1        else if(UART1 == UARTx)
 270   1        {
 271   1        
 272   1        }*/
 273   1        return ((UARTx == UART0)?(uint8_t)SBUF0:(uint8_t)SBUF1);
 274   1      }
 275          
 276          /**
 277            * @brief  Transmits 8 bit data through the USART peripheral.
 278            * @param  Data: The data to transmit.
 279            * @retval None
 280            */
 281          void UART_SendData8(UART_TypeDef UARTx, uint8_t Data)
 282          {
 283   1        if(UART0 == UARTx)
 284   1        {
 285   2            SBUF0 = Data;
 286   2        }
 287   1        else if(UART1 == UARTx)
 288   1        {
 289   2            SBUF1 = Data;
 290   2        }
 291   1      }
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 6   

 292          
 293          /**
 294            * @brief  Transmits 9 bit data through the USART peripheral.
 295            * @param  USARTx: Select the USARTx peripheral.
 296            * @param  Data : The data to transmit.
 297            *         This parameter should be lower than 0x1FF.
 298            * @retval None
 299            */
 300          void UART_SendData9(UART_TypeDef UARTx, uint16_t Data)
 301          {
 302   1        if(UART0 == UARTx)
 303   1        {
 304   2            SBUF0 = Data;
 305   2        }
 306   1        else if(UART1 == UARTx)
 307   1        {
 308   2            SBUF1 = Data;
 309   2        }
 310   1      }
 311          
 312          #if 0
              /**
                * @brief  Transmits break characters.
                * @param  USARTx : where x can be 1 to select the specified USART peripheral.
                * @retval None
                */
              void USART_SendBreak(USART_TypeDef* USARTx)
              {
              
              }
              
              /**
                * @brief  Sets the system clock prescaler.
                * @note   IrDA Low Power mode or smartcard mode should be enabled
                * @note   This function is related to SmartCard and IrDa mode.
                * @param  USARTx: Select the USARTx peripheral.
                * @param  USART_Prescaler: specifies the prescaler clock.
                *         This parameter can be one of the following values:
                *         @par IrDA Low Power Mode
                *         The clock source is diveded by the value given in the register (8 bits)
                *         - 0000 0000 Reserved
                *         - 0000 0001 divides the clock source by 1
                *         - 0000 0010 divides the clock source by 2
                *         - ...........................................................
                *        @par Smart Card Mode
                *        The clock source is diveded by the value given in the register
                *        (5 significant bits) multipied by 2
                *         - 0 0000 Reserved
                *         - 0 0001 divides the clock source by 2
                *         - 0 0010 divides the clock source by 4
                *         - 0 0011 divides the clock source by 6
                *         - ...........................................................
                * @retval None
                */
              void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
              {
              
              }
              
              /**
                * @brief  Sets the address of the USART node.
                * @param  USARTx: Select the USARTx peripheral.
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 7   

                * @param  Address : Indicates the address of the USART node.
                *         This parameter should be lower than 16
                * @retval None
                */
              void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
              {
              
              }
              
              /**
                * @brief  Checks whether the specified USART flag is set or not.
                * @param  USARTx: Select the USARTx peripheral.
                * @param  USART_FLAG specifies the flag to check.
                *         This parameter can be any of the @ref USART_FLAG_TypeDef enumeration.
                * @retval FlagStatus (SET or RESET)
                */
              FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
              {
                FlagStatus status = RESET;
              
                
                /* Return the USART_FLAG status*/
                return status;
              }
              
              /**
                * @brief  Clears the USARTx's pending flags.
                * @param  USARTx : where x can be 1 to select the specified USART peripheral.
                * @param  USART_FLAG: specifies the flag to clear.
                *         This parameter can be any combination of the following values:
                *         USART_FLAG_TC:   Transmission Complete flag.
                *         USART_FLAG_RXNE: Receive data register not empty flag.
                *
                * @Note
                *     - PE (Parity error), FE (Framing error), NE (Noise error), OR (OverRun error)
                *       and IDLE (Idle line detected) flags are cleared by software sequence: a read
                *       operation to USART_SR register (USART_GetFlagStatus())followed by a read
                *       operation to USART_DR register(USART_ReceiveData8() or USART_ReceiveData9()).
                *
                *     - RXNE flag can be also cleared by a read to the USART_DR register
                *       (USART_ReceiveData8()or USART_ReceiveData9()).
                *
                *     - TC flag can be also cleared by software sequence: a read operation to USART_SR
                *       register (USART_GetFlagStatus()) followed by a write operation to USART_DR
                *       register (USART_SendData8() or USART_SendData9()).
                *
                *     - TXE flag is cleared only by a write to the USART_DR register
                *       (USART_SendData8() or USART_SendData9()).
                *
                *     - SBK flag is cleared during the stop bit of break.
                *
                * @retval None
                */
              void USART_ClearFlag(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
              {
                
              }
              #endif
 412          
 413          /**
 414            * @brief  Checks whether the specified USART interrupt has occurred or not.
 415            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 8   

 416            * @param  USART_IT: Specifies the USART interrupt pending bit to check.
 417            *         This parameter can be one of the following values:
 418            *         - USART_IT_TXE: Transmit Data Register empty interrupt
 419            *         - USART_IT_TC: Transmission complete interrupt
 420            *         - USART_IT_RXNE: Receive Data register not empty interrupt
 421            *         - USART_IT_IDLE: Idle line detection interrupt
 422            *         - USART_IT_OR: OverRun Error interrupt
 423            *         - USART_IT_PE: Parity Error interrupt
 424            *         - USART_IT_FE: Frame Error interrupt
 425            *         - USART_IT_NF: Noise Flag Error interrupt
 426            * @retval ITStatus The new state of USART_IT (SET or RESET).
 427            */
 428          ITStatus UART_GetITStatus(UART_TypeDef UARTx, UART_IT_Status_TypeDef UART_IT)
 429          {
 430   1        ITStatus bitstatus = _RESET;
 431   1        uint8_t UART_itStatus = 0x0;
 432   1        
 433   1        if(UART0 == UARTx)
 434   1        {
 435   2          UART_itStatus = SCON0 & UART_IT;
 436   2        }
 437   1        else if(UART1 == UARTx)
 438   1        {
 439   2          UART_itStatus = SCON1 & UART_IT;
 440   2        }
 441   1        
 442   1        if (UART_itStatus != (uint8_t)_RESET )
 443   1        {
 444   2          bitstatus = _SET;
 445   2        }
 446   1        else
 447   1        {
 448   2          bitstatus = _RESET;
 449   2        }
 450   1      
 451   1        /* Return the USART_IT status*/
 452   1        return  bitstatus;
 453   1      }
 454          
 455          /**
 456            * @brief  Clears the USARTx’s interrupt pending bits.
 457            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
 458            * @param  USART_IT: specifies the interrupt pending bit to clear.
 459            *         This parameter can be one of the following values:
 460            *         USART_IT_RXNE: Receive Data register not empty interrupt.
 461            *         USART_IT_TC:   Transmission complete interrupt.
 462            *
 463            * @note
 464            *         - PE (Parity error), FE (Framing error), NE (Noise error),
 465            *         OR (OverRun error) and IDLE (Idle line detected) pending bits are
 466            *         cleared by software sequence: a read operation to USART_SR register
 467            *         (USART_GetITStatus()) followed by a read operation to USART_DR
 468            *         register (USART_ReceiveData8() or USART_ReceiveData9()).
 469            *
 470            *         - RXNE pending bit can be also cleared by a read to the USART_DR register
 471            *         (USART_ReceiveData8() or USART_ReceiveData9()).
 472            *
 473            *         - TC (Transmit complet) pending bit can be also cleared by software
 474            *         sequence: a read operation to USART_SR register (USART_GetITStatus())
 475            *         followed by a write operation to USART_DR register (USART_SendData8()
 476            *         or USART_SendData9()).
 477            *
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 9   

 478            *         - TXE pending bit is cleared only by a write to the USART_DR register
 479            *         (USART_SendData8() or USART_SendData9()).
 480            *
 481            * @retval None
 482            */
 483          void UART_ClearITPendingBit(UART_TypeDef UARTx, UART_IT_Status_TypeDef UART_IT)
 484          {
 485   1        if(UART0 == UARTx)
 486   1        {
 487   2          SCON0 = (~UART_IT);
 488   2        }
 489   1        else if(UART1 == UARTx)
 490   1        {
 491   2          SCON1 = (~UART_IT);
 492   2        }
 493   1      }
 494          
 495          /**
 496            * @brief  Retargets the C library printf function to the USART.
 497            * @param  None
 498            * @retval None
 499            */
 500          //PUTCHAR_PROTOTYPE
 501          //int fputc(int ch, FILE *f)
 502          int fputc(int ch, const char *f)
 503          {
 504   1        /* Place your implementation of fputc here */
 505   1        /* e.g. write a character to the UART0 */
 506   1        UART_SendData8(UART0, (uint8_t) ch);
 507   1        
 508   1        /* Loop until the end of transmission */
 509   1        //while (USART_GetFlagStatus(UART0, USART_FLAG_TC) == RESET)
 510   1        //{}
 511   1      
 512   1        return ch;
 513   1      }
*** WARNING C280 IN LINE 502 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_uart.c: 'f': unreferenced local
             - variable
 514          
 515          
 516          /**
 517            * @}
 518            */
 519          
 520          /**
 521            * @}
 522            */
 523          
 524          /******************* (C) COPYRIGHT 2018 CMSemion *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    602    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.59.0.0   CMS8S003X_UART                                                    05/31/2018 00:23:22 PAGE 10  

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
