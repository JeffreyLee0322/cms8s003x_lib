C51 COMPILER V9.59.0.0   CMS8S003X_ITC                                                     06/03/2018 20:34:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CMS8S003X_ITC
OBJECT MODULE PLACED IN .\Objects\cms8s003x_itc.obj
COMPILER INVOKED BY: D:\Install software\keil5\C51\BIN\C51.EXE ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_
                    -itc.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\CMS8S003x_StdPeriph_Driver\inc) DEBUG PRINT(.\Listings\cms8s0
                    -03x_itc.lst) TABS(2) OBJECT(.\Objects\cms8s003x_itc.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    cms8s003x_itc.c
   4            * @author  LI WEI
   5            * @version V1.0.3
   6            * @date    04/24/2018
   7            * @brief   This file provides all the ITC firmware functions.
   8            ******************************************************************************
   9            * @copy
  10            *
  11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13            * TIME. AS A RESULT, CMSemicon SHALL NOT BE HELD LIABLE FOR ANY
  14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17            *
  18            * <h2><center>&copy; COPYRIGHT 2018 CMSemicon</center></h2>
  19            */
  20          
  21          /* Includes ------------------------------------------------------------------*/
  22          #include "cms8s003x_itc.h"
  23          #include "cms8s003x_spi.h"
  24          #include "cms8s003x_tim01.h"
  25          #include "cms8s003x_tim2.h"
  26          #include "cms8s003x_gpio.h"
  27          #include "cms8s003x_uart.h"
  28          #include "cms8s003x_epwm.h"
  29          
  30          /** @addtogroup CMS8S003x_StdPeriph_Driver
  31            * @{
  32            */
  33          
  34          /* Private typedef -----------------------------------------------------------*/
  35          /* Private define ------------------------------------------------------------*/
  36          /* Private macro -------------------------------------------------------------*/
  37          /* Private variables ---------------------------------------------------------*/
  38          uint32_t timer0Count = 0;
  39          uint32_t timer1Count = 0;
  40          
  41          uint16_t readCount_TIM0 = 0, readCount_TIM1 = 0;
  42          /* Private function prototypes -----------------------------------------------*/
  43          /* Private functions ---------------------------------------------------------*/
  44          
  45          /** @addtogroup ITC_Private_Functions
  46            * @{
  47            */
  48          
  49          
  50          
  51          /**
  52            * @}
  53            */
C51 COMPILER V9.59.0.0   CMS8S003X_ITC                                                     06/03/2018 20:34:54 PAGE 2   

  54          
  55          /** @addtogroup ITC_Public_Functions
  56            * @{
  57            */
  58          
  59          /**
  60            * @brief  Deinitializes the ITC registers to their default reset value.
  61            * @param  None
  62            * @retval None
  63           */
  64          void ITC_DeInit(void)
  65          {
  66   1      
  67   1      }
  68          
  69          //unsigned int times = 0;   
  70          void SPI_ISR() interrupt 22
  71          {
  72   1        FlagStatus status = 0;
  73   1        ITStatus  itS = 0;
  74   1        if(SPI_GetFlagStatus(Peripheral_SPI_Interrupt)) //SPI总中断指示位  清除具体的中断标志位后 此位自动清除
  75   1        {
  76   2          if(SPI_GetITStatus(SPI_FLAG_SPISIF))        //SPI传输完毕中断标志位 先读SPSR 再度写SPDR后清0
  77   2          {
  78   3             /*if(times<5)
  79   3             {
  80   3               Master_Received[times] = SPI_ReceiveData();
  81   3              
  82   3               if(times < 4)
  83   3                 SPI_SendData(0x40);
  84   3             }
  85   3             times++;*/
  86   3          }
  87   2          else if(SPI_GetITStatus(SPI_FLAG_WCOL))   //SPI 写冲突中断标志位 先读SPSR 再读写SPDR后清0
  88   2          {
  89   3      
  90   3          }
  91   2          else if(SPI_GetITStatus(SPI_FLAG_MODF))   //SPI模式错误中断标志 先读SPSR 再读写SPCR后清0
  92   2          {
  93   3          }
  94   2        }
  95   1      }
  96          
  97          
  98          void timer0_int (void) interrupt 1
  99          {
 100   1        //这里不需要判断中断标志位，且中断标志位硬件自动清零
 101   1        uint32_t counter = 0;
 102   1        readCount_TIM0 = TIM0_GetCounter();
 103   1        timer0Count++;
 104   1        if(timer0Count > 100) timer0Count = 0;
 105   1        if(timer0Count%2) GPIO_WriteBit(GPIO_PORT_1, GPIO_PIN_5, 1);
 106   1        else GPIO_WriteBit(GPIO_PORT_1, GPIO_PIN_5, 0);
 107   1        //counter = TIM0_GetCounter();
 108   1      }
 109          
 110          void timer1_int (void) interrupt 3
 111          {
 112   1        P1_5 =~ P1_5;
 113   1        //TH1 = (uint8_t)((8192 - (uint16_t)(1000000.0 / 9600 / 0.25))>>5);
 114   1        //TL1 = (uint8_t)((8192 - (uint16_t)(1000000.0 / 9600 / 0.25))&0xFF);
 115   1        /*readCount_TIM1 = TIM1_GetCounter();
C51 COMPILER V9.59.0.0   CMS8S003X_ITC                                                     06/03/2018 20:34:54 PAGE 3   

 116   1        timer1Count++;
 117   1        if(timer1Count > 100) timer1Count = 0;
 118   1        if(timer1Count%2) GPIO_WriteBit(GPIO_PORT_1, GPIO_PIN_6, 1);
 119   1        else GPIO_WriteBit(GPIO_PORT_1, GPIO_PIN_6, 0);*/
 120   1      }
 121          
 122          void timer2_int (void) interrupt 5
 123          {
 124   1        //P1_5 =~ P1_5;
 125   1        if(TIM2_GetITStatus(TIM2_Overflow_Flag))
 126   1        {
 127   2            TIM2_ClearITPendingBit(TIM2_Overflow_Flag);
 128   2        }
 129   1        
 130   1        if(TIM2_GetITStatus(TIM2_Reload_Flag))
 131   1        {
 132   2            TIM2_ClearITPendingBit(TIM2_Reload_Flag);
 133   2        }
 134   1        
 135   1        if(TIM2_GetITStatus(TIM2_OOC3_Flag))
 136   1        {
 137   2            TIM2_ClearITPendingBit(TIM2_OOC3_Flag);
 138   2        }
 139   1        
 140   1        if(TIM2_GetITStatus(TIM2_OOC2_Flag))
 141   1        {
 142   2            TIM2_ClearITPendingBit(TIM2_OOC2_Flag);
 143   2        }
 144   1        
 145   1        if(TIM2_GetITStatus(TIM2_OOC1_Flag))
 146   1        {
 147   2            TIM2_ClearITPendingBit(TIM2_OOC1_Flag);
 148   2        }
 149   1        
 150   1        if(TIM2_GetITStatus(TIM2_OOC0_Flag))
 151   1        {
 152   2            TIM2_ClearITPendingBit(TIM2_OOC0_Flag);
 153   2        }
 154   1      }
 155          
 156          void timer3_int (void) interrupt 15
 157          {
 158   1      
 159   1      }
 160          
 161          void timer4_int (void) interrupt 16
 162          {
 163   1      
 164   1      }
 165          
 166          void uart0_int (void) interrupt 4
 167          {
 168   1        
 169   1        if(UART_GetITStatus(UART0, Send_IT_Status))
 170   1        {
 171   2            UART_ClearITPendingBit(UART0, Send_IT_Status);
 172   2        }
 173   1        
 174   1        if(UART_GetITStatus(UART0, Receive_IT_Status))
 175   1        {
 176   2            UART_ClearITPendingBit(UART0, Send_IT_Status);
 177   2        }
C51 COMPILER V9.59.0.0   CMS8S003X_ITC                                                     06/03/2018 20:34:54 PAGE 4   

 178   1      }
 179          
 180          void uart1_int (void) interrupt 6
 181          {
 182   1        if(UART_GetITStatus(UART1, Send_IT_Status))
 183   1        {
 184   2            UART_ClearITPendingBit(UART1, Send_IT_Status);
 185   2        }
 186   1        
 187   1        if(UART_GetITStatus(UART1, Receive_IT_Status))
 188   1        {
 189   2            UART_ClearITPendingBit(UART1, Send_IT_Status);
 190   2        }
 191   1      }
 192          
 193          void pwm_int (void) interrupt 18
 194          {
 195   1        if(EPWM_GetPeriodITStatus(EPWM0_PeriodIT))
 196   1        {
 197   2            EPWM_ClearPeriodITStatus(EPWM0_PeriodIT);
 198   2        }
 199   1        
 200   1        if(EPWM_GetPeriodITStatus(EPWM1_PeriodIT))
 201   1        {
 202   2            EPWM_ClearPeriodITStatus(EPWM1_PeriodIT);
 203   2        }
 204   1        
 205   1        if(EPWM_GetPeriodITStatus(EPWM2_PeriodIT))
 206   1        {
 207   2            EPWM_ClearPeriodITStatus(EPWM2_PeriodIT);
 208   2        }
 209   1        
 210   1        if(EPWM_GetZeroITStatus(EPWM3_ZeroIT))
 211   1        {
 212   2            EPWM_ClearZeroITStatus(EPWM3_ZeroIT);
 213   2        }
 214   1        
 215   1        if(EPWM_GetZeroITStatus(EPWM4_ZeroIT))
 216   1        {
 217   2            EPWM_ClearZeroITStatus(EPWM4_ZeroIT);
 218   2        }
 219   1        
 220   1        if(EPWM_GetZeroITStatus(EPWM5_ZeroIT))
 221   1        {
 222   2            EPWM_ClearZeroITStatus(EPWM5_ZeroIT);
 223   2        }
 224   1      }
 225          
 226          /**
 227            * @}
 228            */
 229          
 230          /**
 231            * @}
 232            */
 233          
 234          /******************* (C) COPYRIGHT 2018 CMSemicon *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    724    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.59.0.0   CMS8S003X_ITC                                                     06/03/2018 20:34:54 PAGE 5   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
