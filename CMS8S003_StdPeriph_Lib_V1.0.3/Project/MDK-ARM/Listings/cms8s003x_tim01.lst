C51 COMPILER V9.56.0.0   CMS8S003X_TIM01                                                   05/18/2018 18:04:00 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CMS8S003X_TIM01
OBJECT MODULE PLACED IN .\Objects\cms8s003x_tim01.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_tim01.c OMF2 OP
                    -TIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\CMS8S003x_StdPeriph_Driver\inc) DEBUG PRINT(.\Listings\cms8s003x_tim01.lst
                    -) TABS(2) OBJECT(.\Objects\cms8s003x_tim01.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    cms8s003x_tim1.c
   4            * @author  LI WEI
   5            * @version V1.0.0
   6            * @date    04/24/2018
   7            * @brief   This file provides all the TIM1 firmware functions.
   8            ******************************************************************************
   9            * @copy
  10            *
  11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13            * TIME. AS A RESULT, CMSemicon SHALL NOT BE HELD LIABLE FOR ANY
  14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17            *
  18            * <h2><center>&copy; COPYRIGHT 2018 CMSemicon</center></h2>
  19            */
  20          
  21          /* Includes ------------------------------------------------------------------*/
  22          #include "cms8s003x_tim01.h"
  23          
  24          /** @addtogroup CMS8S003x_StdPeriph_Driver
  25            * @{
  26            */
  27          
  28          /* Private typedef -----------------------------------------------------------*/
  29          /* Private define ------------------------------------------------------------*/
  30          /* Private macro -------------------------------------------------------------*/
  31          /* Private variables ---------------------------------------------------------*/
  32          /* Private function prototypes -----------------------------------------------*/
  33          
  34          /**
  35            * @addtogroup TIM0_Public_Functions
  36            * @{
  37            */
  38          
  39          /**
  40            * @brief  Deinitializes the TIM0 peripheral registers to their default reset values.
  41            * @param  None
  42            * @retval None
  43            */
  44          void TIM0_DeInit(void)
  45          {
  46   1        TMOD &= 0xf0; //timer0 gate set 0
  47   1        TCON &= 0xCF; //timer0  control register clear
  48   1      }
  49          
  50          void TIM1_DeInit(void)
  51          {
  52   1        TMOD &= 0xf; //timer1 gate set 0
  53   1        TCON &= 0x3F; //timer1  control register clear
C51 COMPILER V9.56.0.0   CMS8S003X_TIM01                                                   05/18/2018 18:04:00 PAGE 2   

  54   1      }
  55          
  56          void TIM0_Init(TIM01_Init_TypeDef *TIM0_InitDef)
  57          {
  58   1        TMOD &= 0xf8; //GATE0/CT0/TOM0 clear 0-2 bit, set GATE0 bit.
  59   1      
  60   1        //CKCON clear 3 bit
  61   1        CKCON &= 0xf7;
  62   1      
  63   1        //Set
  64   1        TMOD |= (((uint8_t)((TIM0_InitDef->Timer_Function) << 2)) | ((uint8_t)(TIM0_InitDef->Timer_Mode)));
  65   1        CKCON |= ((uint8_t)((TIM0_InitDef->Timer_Clock) << 3));
  66   1      
  67   1        if((TIM0_InitDef->Timer_Mode) == Mode0_13Bit_Timer_Counter)
  68   1        {
  69   2          TH0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)>>5);
  70   2          TL0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)&0x1f);
  71   2        }else if((TIM0_InitDef->Timer_Mode) == Mode1_16Bit_Timer_Counter)
  72   1        {
  73   2          TH0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)>>8);
  74   2          TL0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)&0xff);
  75   2        }else if((TIM0_InitDef->Timer_Mode) == Mode2_8Bit_AutoLoad_Timer_Counter)
  76   1        {
  77   2          TH0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)&0xff);
  78   2          TL0 = (uint8_t)((TIM0_InitDef->Timer_InitValue)&0xff);
  79   2        }else
  80   1        {
  81   2      
  82   2        }
  83   1      }
  84          
  85          void TIM1_Init(TIM01_Init_TypeDef *TIM1_InitDef)
  86          {
  87   1      
  88   1      }
*** WARNING C280 IN LINE 85 OF ..\..\Libraries\CMS8S003x_StdPeriph_Driver\src\cms8s003x_tim01.c: 'TIM1_InitDef': unrefer
             -enced local variable
  89          
  90          void TIM0_Cmd(FunctionalState NewState)
  91          {
  92   1        if (NewState != _DISABLE)
  93   1        {
  94   2          TCON |= TIMER0_START_BIT; /* Enable the TIMER0*/
  95   2        }
  96   1        else
  97   1        {
  98   2          TCON &= (uint8_t)(~TIMER0_START_BIT); /* Disable the TIMER0*/
  99   2        }
 100   1      }
 101          
 102          void TIM1_Cmd(FunctionalState NewState)
 103          {
 104   1        if (NewState != _DISABLE)
 105   1        {
 106   2          TCON |= TIMER1_START_BIT; /* Enable the TIMER0*/
 107   2        }
 108   1        else
 109   1        {
 110   2          TCON &= (uint8_t)(~TIMER1_START_BIT); /* Disable the TIMER0*/
 111   2        }
 112   1      }
 113          
C51 COMPILER V9.56.0.0   CMS8S003X_TIM01                                                   05/18/2018 18:04:00 PAGE 3   

 114          
 115          void TIM0_ITConfig(TIM_PriorityTypeDef TIM0_Priority, FunctionalState NewState)
 116          {
 117   1        IP &= 0xfd; //clear bit 1
 118   1        IP |= (TIM0_Priority<<1);
 119   1        
 120   1        /* Set the SPI IT mask Register */
 121   1        if (NewState != _DISABLE)
 122   1        {
 123   2          IE |= TIME0_INTERRUPT_ENABLE_BIT; /* Enable the SPI IT */
 124   2        }
 125   1        else
 126   1        {
 127   2          IE &= (uint8_t)(~TIME0_INTERRUPT_ENABLE_BIT); /* Disable the SPI IT */
 128   2        }
 129   1      }
 130          
 131          void TIM1_ITConfig(TIM_PriorityTypeDef TIM1_Priority, FunctionalState NewState)
 132          {
 133   1        IP &= 0xf7; //clear bit 3
 134   1        IP |= (TIM1_Priority<<3);
 135   1        
 136   1        /* Set the SPI IT mask Register */
 137   1        if (NewState != _DISABLE)
 138   1        {
 139   2          IE |= TIME1_INTERRUPT_ENABLE_BIT; /* Enable the SPI IT */
 140   2        }
 141   1        else
 142   1        {
 143   2          IE &= (uint8_t)(~TIME1_INTERRUPT_ENABLE_BIT); /* Disable the SPI IT */
 144   2        }
 145   1      }
 146          
 147          /**
 148            * @brief  Gets the TIM1 Counter value.
 149            * @param  None
 150            * @retval Counter Register value.
 151            */
 152          uint16_t TIM0_GetCounter(void)
 153          {
 154   1        /* Get the Counter Register value */
 155   1        uint16_t tmpcntr = 0;
 156   1        uint8_t tmpcntrl = 0, tmpcntrh = 0;
 157   1      
 158   1        tmpcntrh = TH0;
 159   1        tmpcntrl = TL0;
 160   1      
 161   1        tmpcntr  = (uint16_t)(tmpcntrl);
 162   1        tmpcntr |= (uint16_t)((uint16_t)tmpcntrh << 8);
 163   1      
 164   1        /* Get the Counter Register value */
 165   1        return (uint16_t)tmpcntr;
 166   1      }
 167          
 168          uint16_t TIM1_GetCounter(void)
 169          {
 170   1        /* Get the Counter Register value */
 171   1        uint16_t tmpcntr = 0;
 172   1        uint8_t tmpcntrl = 0, tmpcntrh = 0;
 173   1      
 174   1        tmpcntrh = TH1;
 175   1        tmpcntrl = TL1;
C51 COMPILER V9.56.0.0   CMS8S003X_TIM01                                                   05/18/2018 18:04:00 PAGE 4   

 176   1      
 177   1        tmpcntr  = (uint16_t)(tmpcntrl);
 178   1        tmpcntr |= (uint16_t)((uint16_t)tmpcntrh << 8);
 179   1      
 180   1        /* Get the Counter Register value */
 181   1        return (uint16_t)tmpcntr;
 182   1      }
 183          /**
 184            * @brief  Checks whether the TIM1 interrupt has occurred or not.
 185            * @param  TIM1_IT specifies the TIM1 interrupt source to check.
 186            *   This parameter can be one of the @ref TIM1_IT_TypeDef enumeration.
 187            * @retval ITStatus The new state of the TIM1_IT(SET or RESET).
 188            */
 189          
 190          ITStatus TIM0_GetITStatus(void)
 191          {
 192   1        ITStatus bitstatus = _RESET;
 193   1      
 194   1        uint8_t TIM0_itStatus = 0x0;
 195   1      
 196   1        /* Check the parameters */
 197   1        //assert_param(IS_TIM1_GET_IT(TIM1_IT));
 198   1      
 199   1        TIM0_itStatus = (uint8_t)(TCON & 0x20);
 200   1      
 201   1        if (TIM0_itStatus != (uint8_t)_RESET )
 202   1        {
 203   2          bitstatus = _SET;
 204   2        }
 205   1        else
 206   1        {
 207   2          bitstatus = _RESET;
 208   2        }
 209   1        return (ITStatus)(bitstatus);
 210   1      }
 211          
 212          ITStatus TIM1_GetITStatus(void)
 213          {
 214   1        ITStatus bitstatus = _RESET;
 215   1      
 216   1        uint8_t TIM0_itStatus = 0x0;
 217   1      
 218   1        /* Check the parameters */
 219   1        //assert_param(IS_TIM1_GET_IT(TIM1_IT));
 220   1      
 221   1        TIM0_itStatus = (uint8_t)(TCON & 0x80);
 222   1      
 223   1        if (TIM0_itStatus != (uint8_t)_RESET )
 224   1        {
 225   2          bitstatus = _SET;
 226   2        }
 227   1        else
 228   1        {
 229   2          bitstatus = _RESET;
 230   2        }
 231   1        return (ITStatus)(bitstatus);
 232   1      }
 233          
 234          /**
 235            * @brief  Clears the TIM0's interrupt pending bits.
 236            * @param  TIM1_IT specifies the pending bit to clear.
 237            *   This parameter can be one of the @ref TIM1_IT_TypeDef enumeration.
C51 COMPILER V9.56.0.0   CMS8S003X_TIM01                                                   05/18/2018 18:04:00 PAGE 5   

 238            * @retval None.
 239            */
 240          void TIM0_ClearITPendingBit(void)
 241          {
 242   1        TCON &= 0xdf;
 243   1      }
 244          
 245          void TIM1_ClearITPendingBit(void)
 246          {
 247   1        TCON &= 0x7f;
 248   1      }
 249          /**
 250            * @}
 251            */
 252          
 253          /**
 254            * @}
 255            */
 256          
 257          /************************************ (C) COPYRIGHT 2018 CMSemicon *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    263    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
